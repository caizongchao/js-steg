// Generated by CoffeeScript 1.3.3
(function() {

  this.solveConstraints = function(variableCount, constraints, canBeAllZeros) {
    var assignment, propogateConstraints, solve;
    solve = function(variableCount, constraints) {
      var allZero, assignment, backtrack, conflictSet, constraint, current, i, loopLimit, looped, newCurrent, nowBacktracking, satisfies, validBacktracks, variable, _i, _j, _k, _len, _len1, _ref, _ref1;
      satisfies = function(constraint, assignment, current) {
        var element, xor, _i, _len, _ref;
        xor = 0;
        _ref = constraint.elements;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          if (element > current) {
            return true;
          }
          xor = (xor + assignment[element]) % 2;
        }
        return xor === constraint.mustXorTo;
      };
      conflictSet = function(variable) {
        var constraint, element, set, _i, _j, _len, _len1, _ref;
        set = [];
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          constraint = constraints[_i];
          if (constraint.elements.indexOf(variable) > -1) {
            _ref = constraint.elements;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              element = _ref[_j];
              if (set.indexOf(element) < 0) {
                set.push(element);
              }
            }
          }
        }
        set.sort(function(x, y) {
          return y - x;
        });
        return set;
      };
      allZero = function(assignment) {
        var i, _i, _ref;
        for (i = _i = 0, _ref = variableCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (assignment[i] === 1 || assignment[i] === void 0) {
            return false;
          }
        }
        return true;
      };
      assignment = [];
      validBacktracks = [];
      looped = 0;
      loopLimit = 10000;
      current = 0;
      nowBacktracking = false;
      while (current < variableCount) {
        looped++;
        if (looped > loopLimit) {
          break;
        }
        if ((looped % 500000) === 0) {
          console.log("On our " + looped + "th step while solving");
          console.log("Our current assignment is " + assignment.toString());
        }
        if (assignment[current] === void 0) {
          assignment[current] = Math.floor(Math.random() + 0.5);
          validBacktracks.push(current);
        } else if (nowBacktracking) {
          assignment[current] = (assignment[current] + 1) % 2;
        } else if (!nowBacktracking) {
          validBacktracks.push(current);
        }
        backtrack = false;
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          constraint = constraints[_i];
          if (!satisfies(constraint, assignment, current)) {
            backtrack = true;
          }
        }
        if (!canBeAllZeros && allZero(assignment)) {
          backtrack = true;
        }
        if (backtrack) {
          nowBacktracking = true;
          if (validBacktracks.length > 0) {
            newCurrent = -1;
            _ref = conflictSet(current);
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              variable = _ref[_j];
              for (i = _k = _ref1 = validBacktracks.length - 1; _ref1 <= 0 ? _k <= 0 : _k >= 0; i = _ref1 <= 0 ? ++_k : --_k) {
                if (variable === validBacktracks[i]) {
                  newCurrent = validBacktracks[i];
                  validBacktracks.splice(i, validBacktracks.length - i);
                  break;
                }
                if (variable > validBacktracks[i]) {
                  break;
                }
              }
              if (newCurrent !== -1) {
                break;
              }
            }
            if (newCurrent === -1) {
              console.log("We have a conflict but there is no conflicting element to change. Give up.");
              return;
            } else {
              current = newCurrent;
            }
          } else {
            console.log("Nowhere to backtrack to and maxOnes is already " + variableCount + " so no assignment is valid");
            return;
          }
        } else {
          nowBacktracking = false;
          current++;
        }
      }
      if (looped > loopLimit) {
        console.log("ERROR: TRYING TO SOLVE SOME MATRIX EQUATION TOOK TOO LONG (NON-MINIMAL)");
        console.log("Our final assignment was " + assignment.toString());
        return;
      }
      console.log("We took " + looped + " loops to solve this.");
      return assignment;
    };
    propogateConstraints = function(constraints) {
      var constrainti, constraintj, count, excOrElements, i, j, k, mustXorTo, newConstraint, newConstraints, temp, _i, _j, _len, _ref, _ref1;
      newConstraints = [];
      count = 0;
      for (i = _i = 0, _len = constraints.length; _i < _len; i = ++_i) {
        constrainti = constraints[i];
        if ((i + 1) <= constraints.length - 1) {
          for (j = _j = _ref = i + 1, _ref1 = constraints.length - 1; _ref <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = _ref <= _ref1 ? ++_j : --_j) {
            constraintj = constraints[j];
            temp = constrainti.elements.concat(constraintj.elements);
            temp = temp.sort(function(x, y) {
              return x - y;
            });
            excOrElements = [];
            k = 0;
            while (k < temp.length - 1) {
              if ((k === temp.length - 1) || (temp[k] !== temp[k + 1])) {
                excOrElements.push(temp[k]);
                k++;
              } else {
                k += 2;
              }
            }
            if ((excOrElements.length <= Math.min(constraintj.elements.length, constrainti.elements.length)) && (excOrElements.length > 0)) {
              mustXorTo = (constrainti.mustXorTo + constraintj.mustXorTo) % 2;
              newConstraint = {
                elements: excOrElements,
                mustXorTo: mustXorTo,
                expandedFrom: [constraintj.elements.length, constrainti.elements.length]
              };
              newConstraints.push(newConstraint);
              count++;
            }
            if (count > 400) {
              break;
            }
          }
        }
        if (count > 400) {
          break;
        }
      }
      return newConstraints.concat(constraints);
    };
    return assignment = solve(variableCount, constraints);
  };

}).call(this);
