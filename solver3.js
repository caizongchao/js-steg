// Generated by CoffeeScript 1.3.3
(function() {

  this.solveConstraintsMinimally = function(variableCount, constraints, canBeAllZeros, minimizeHammingDist) {
    var assignedTo, assignment, constraint, count, element, i, mappedAssignment, solve, variable, variableCountArray, variableInverseMap, variableMap, variablesWithCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _p, _ref, _ref1, _ref2;
    solve = function(variableCount, constraints) {
      var allZero, assignment, backtrack, constraint, current, currentOnes, i, loopLimit, looped, maxOnes, nowBacktracking, satisfies, validBacktracks, _i, _j, _len, _ref, _ref1;
      satisfies = function(constraint, assignment) {
        var element, xor, _i, _len, _ref;
        xor = 0;
        _ref = constraint.elements;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          if (assignment[element] === void 0) {
            return true;
          }
          xor = (xor + assignment[element]) % 2;
        }
        return xor === constraint.mustXorTo;
      };
      allZero = function(assignment) {
        var i, _i, _ref;
        for (i = _i = 0, _ref = variableCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (assignment[i] === 1 || assignment[i] === void 0) {
            return false;
          }
        }
        return true;
      };
      assignment = [];
      validBacktracks = [];
      looped = 0;
      loopLimit = 10000000;
      maxOnes = 1;
      currentOnes = 0;
      current = 0;
      nowBacktracking = false;
      while (current < variableCount) {
        looped++;
        if (looped > loopLimit) {
          break;
        }
        if ((looped % 500000) === 0) {
          console.log("On our " + looped + "th step while solving");
          console.log("Our current assignment is " + assignment.toString());
        }
        if (assignment[current] === void 0) {
          if (minimizeHammingDist) {
            assignment[current] = 0;
          } else {
            assignment[current] = Math.floor(Math.random() + 0.5);
            if (assignment[current] === 1) {
              currentOnes++;
            }
          }
          validBacktracks.push(current);
        } else if (nowBacktracking) {
          assignment[current] = (assignment[current] + 1) % 2;
          if (assignment[current] === 1) {
            currentOnes++;
          }
        } else if (!nowBacktracking) {
          console.log("ERRORRR!!!!!! Shouldn't end up in this case");
        }
        backtrack = false;
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          constraint = constraints[_i];
          if (!satisfies(constraint, assignment)) {
            backtrack = true;
            break;
          }
        }
        if (!canBeAllZeros && allZero(assignment)) {
          backtrack = true;
        }
        if (minimizeHammingDist && currentOnes > maxOnes) {
          backtrack = true;
        }
        if (backtrack) {
          nowBacktracking = true;
          if (validBacktracks.length > 0) {
            current = validBacktracks.pop();
            if (current + 1 <= variableCount - 1) {
              for (i = _j = _ref = current + 1, _ref1 = variableCount - 1; _ref <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = _ref <= _ref1 ? ++_j : --_j) {
                if (assignment[i] === 1) {
                  currentOnes--;
                }
              }
            }
            assignment.length = current + 1;
          } else {
            if (maxOnes < variableCount) {
              maxOnes++;
              assignment.length = 0;
              current = 0;
              currentOnes = 0;
            } else {
              throw "Nowhere to backtrack to and maxOnes is already " + variableCount + " so no assignment is valid";
              return -1;
            }
          }
        } else {
          nowBacktracking = false;
          current++;
        }
      }
      if (looped > loopLimit) {
        throw "ERROR: TRYING TO SOLVE SOME MATRIX EQUATION TOOK TOO LONG";
        return -1;
      }
      return assignment;
    };
    variableCountArray = [];
    for (i = _i = 0, _ref = variableCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      variableCountArray[i] = 0;
    }
    for (_j = 0, _len = constraints.length; _j < _len; _j++) {
      constraint = constraints[_j];
      _ref1 = constraint.elements;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        element = _ref1[_k];
        variableCountArray[element]++;
      }
    }
    variablesWithCount = [];
    for (i = _l = 0, _len2 = variableCountArray.length; _l < _len2; i = ++_l) {
      count = variableCountArray[i];
      variablesWithCount[i] = {
        variable: i,
        count: count
      };
    }
    variablesWithCount.sort(function(x, y) {
      return y.count - x.count;
    });
    variableInverseMap = variablesWithCount.map(function(varAndCount) {
      return varAndCount.variable;
    });
    variableMap = [];
    for (i = _m = 0, _len3 = variableInverseMap.length; _m < _len3; i = ++_m) {
      variable = variableInverseMap[i];
      variableMap[variable] = i;
    }
    for (_n = 0, _len4 = constraints.length; _n < _len4; _n++) {
      constraint = constraints[_n];
      _ref2 = constraint.elements;
      for (i = _o = 0, _len5 = _ref2.length; _o < _len5; i = ++_o) {
        element = _ref2[i];
        constraint.elements[i] = variableMap[element];
      }
    }
    assignment = solve(variableCount, constraints);
    mappedAssignment = [];
    for (i = _p = 0, _len6 = assignment.length; _p < _len6; i = ++_p) {
      assignedTo = assignment[i];
      mappedAssignment[variableInverseMap[i]] = assignedTo;
    }
    return mappedAssignment;
  };

}).call(this);
