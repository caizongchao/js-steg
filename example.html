<!DOCTYPE html>
<html>
  <head>
    <script src="jpg_encoder.js"></script>
    <script src="jpg_decoder.js"></script>
    <script src="seedrandom.js"></script>
    <script src="matrix.js"></script>
    <script src="solver3.js"></script>
    <script src="solver4.js"></script>
    <title>Steganography</title>
  </head>
  <body>
    <input type="file" id="image-select"></input><br />
    Message to send: <input type="text" id="message" value="" style="width:800px"></input><br />
    Password: <input type="text" id="password" value="P4ssw0rd"></input><br />
    <button id="encodeButton">Encode</button><button id="decodeButton">Decode</button>
    <p id="status"></p>
    <img id="encoded"></img>
    <script>

    var errorRateCaused;
    var mlbcForEncodingAndDecoding = JSON.parse('{"u":1,"t":2,"k":1,"n":10,"l":4,"r":5,"G1":[[1,0,0,0,0,0,1,0,1,0]],"Ht":[[0,1,0,1,0],[0,1,0,0,1],[1,1,1,0,1],[0,1,1,1,0],[1,1,1,1,1],[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]],"Jt":[[1],[1],[1],[0],[0],[0],[0],[0],[0],[0]],"G0":[[1,1,0,0,0,0,0,0,1,1],[1,0,1,0,0,1,0,1,1,1],[0,0,0,1,0,0,1,1,1,0],[0,0,0,0,1,1,1,1,1,1]]}');

      //STATUS MANAGEMENT

      function updateStatus(message) {
        console.log("Updating status to "+message);
        document.getElementById("status").innerText = message;
      }

      // JPEG FUNCTIONS

      function encodeData(theImgData, qf, dctFunction){
        var encoder = new JPEGEncoder();
        var jpegURI = encoder.encode(theImgData,qf,dctFunction);
        var img = document.getElementById('encoded');
        img.src = jpegURI;
      }

      function decodeImage(canvasId, url, decodingDctFunction, callback) {
        var j = new JpegImage();
        j.onload = function(DU_DCT_ARRAY) {
          // Hack to handle the luma sometimes being 0 index and sometimes 1 indexed
          if (DU_DCT_ARRAY[0] == undefined) {
            decodingDctFunction(DU_DCT_ARRAY[1], DU_DCT_ARRAY[1].length);
          } else {
            decodingDctFunction(DU_DCT_ARRAY[0], DU_DCT_ARRAY[0].length);
          }
          callback();
        };
        j.load(url, true);
      }

      // DCT FUNCTIONS AND THEIR WRAPPERS

      function encodingDctFunction(DU_DCT_ARRAY, blocks, message, password, mlbc) {
        function makeChanges(messageToHide, LUMA_ARRAY) {
          var stuckBitErrors = 0;
          for (var i = 0; i<messageToHide.length; i++) {
            pos = intToPair(coeffs[i]);
            if (Math.abs(LUMA_ARRAY[pos.block][pos.k]%2) != messageToHide[i]) {
              if (LUMA_ARRAY[pos.block][pos.k] != 0) { // If the bit isn't stuck
                if (LUMA_ARRAY[pos.block][pos.k] < 0) { //F5 embedding
                  LUMA_ARRAY[pos.block][pos.k] += 1;
                } else {
                  LUMA_ARRAY[pos.block][pos.k] -= 1;
                }
              } else {
                stuckBitErrors++;
              }
            }
          }  
          return stuckBitErrors;
        }
        function coeffsToStuckBitStream(coeffs, LUMA_ARRAY) {
          stream = [];
          for (var i = 0; i<coeffs.length; i++) {
            pos = intToPair(coeffs[i]);
            if (LUMA_ARRAY[pos.block][pos.k] == 0) {
              stream.push(0);
            } else {
              stream.push(1);
            }
          }
          return stream;
        }
        updateStatus("Embedding secret message. Please wait...");
        LUMA_ARRAY = DU_DCT_ARRAY[0];
        coeffs = getValidCoeffs(LUMA_ARRAY, blocks);
        console.log("We have "+coeffs.length+" coeffs within to encode data");
        shuffle(coeffs, password);
        var stream = coeffsToStuckBitStream(coeffs, LUMA_ARRAY);
        messageToHide = encodeLongMessage(mlbc, message, stream);
        stuckBitErrors = makeChanges(messageToHide, LUMA_ARRAY);
        errorRateCaused = stuckBitErrors/messageToHide.length;
        console.log("We caused "+stuckBitErrors+" ("+errorRateCaused*100+"%) errors to occur in unavoidable stuck bits");   

        //TODO: Refactor status
        if (errorRateCaused>0.01) {
          updateStatus("Encoding almost complete although the cover is very bad. We recommend choosing a new one or reducing the size of your message and trying again.");
        } else if (errorRateCaused>0.005) {
          updateStatus("Encoding almost complete, although the image is not an ideal cover and the message may have a higher than expected error rate. Tip: images with large areas of a single colour, such as sky, are not suitable for steganography.");
        } else { 
          updateStatus("Encoding complete.");
        }
      }

      function decodingDctFunction(LUMA_ARRAY, blocks, password, mlbc) {
        function coeffsToStream(coeffs, LUMA_ARRAY) {
          stream = [];
          for (var i = 0; i<coeffs.length; i++) {
            pos = intToPair(coeffs[i]);
            stream.push(Math.abs(LUMA_ARRAY[pos.block][pos.k]%2));
          }
        }
        coeffs = getValidCoeffs(LUMA_ARRAY, blocks);
        console.log(coeffs.length+" coefficients were available for storing.");
        shuffle(coeffs, password);
        stream = coeffsToStream(coeffs, LUMA_ARRAY);

        message = decodeLongMessage(mlbc, stream);
        updateStatus("Message received: \""+message+"\"");
      }

      function createEncodingDctFunction(message, password, mlbc) {
        return function(DU_DCT_ARRAY, blocks) {
          encodingDctFunction(DU_DCT_ARRAY, blocks, message, password, mlbc);
        } 
      }

      function createDecodingDctFunction(password, mlbc) {
        return function(DU_DCT_ARRAY, blocks) {
          decodingDctFunction(DU_DCT_ARRAY, blocks, password, mlbc);
        }
      }

      // ENCODING AND DECODING HELPERS

      function getValidCoeffs(arr, blocks) {
        var coeffs = []
        for (var block = 0; block < blocks; block++){
          for (var k = 1; k <= 1; k++) {
            coeffs.push(pairToInt(block, k));
          }
        }
        return coeffs;
      }

      function intToPair(i) { // Used to convert coefficient block, mode pairs to integers
        var block = Math.floor(i/64);
        var k = i%64;
        return {block: block, k: k};
      }

      function pairToInt(block, k) { // Used to convert integers to coefficient block, mode pairs
        return (64*block + k);
      }

      function random(from, to) { // Used in shuffling
        return (from + Math.floor(0.5 + Math.random()*(to-from)));
      }

      function shuffle(arr, password) { // Knuth shuffle
        Math.seedrandom(password);
        for (var i = arr.length - 1; i > 0; i--) {
          j = random(0, i)
          swap = arr[j];
          arr[j] = arr[i];
          arr[i] = swap;
        }
        Math.seedrandom();
        return arr;
      }

      // JPEG HELPER FUNCTIONS

      function getImageDimensions(url, callback){
        var img = document.createElement('img');
        img.onload = function() {
          callback({width: img.width, height: img.height});
        };
        img.src = url; // Set source path
      }

      function encodeCanvas(canvasId, qf, dctFunction){
        var cvs = document.getElementById(canvasId);
        var ctx = cvs.getContext("2d");
        var theImgData = (ctx.getImageData(0, 0, cvs.width, cvs.height));
        encodeData(canvasId, qf, dctFunction);
      }

      function getImageDataFromURL(URL, callback){
        var img = document.createElement('img');
        img.onload = function() {
          var cvs = document.createElement('canvas');
          cvs.width = img.width;m
          cvs.height = img.height;
          var ctx = cvs.getContext("2d");
          ctx.drawImage(img,0,0);
          window.data = ctx.getImageData(0, 0, cvs.width, cvs.height);
          callback(ctx.getImageData(0, 0, cvs.width, cvs.height));
        };
        img.src = URL; // Set source path
      }

      //USER INTERFACE CODE

      function decodeImageClicked () {
        decodeImage('canvas', objectURL, createDecodingDctFunction(mlbcForEncodingAndDecoding), function(){});
      }

      function encodeImageClicked() {
        if (document.getElementById("message").value.length > 0) {
          updateStatus("Recompressing image. Please wait...");
          setTimeout(function() {
            getImageDataFromURL(objectURL, 
              function(data) {
                encodeData(data, 75, createEncodingDctFunction(message, password, mlbcForEncodingAndDecoding));
              }
            );
          }, 100);
        } else {
          updateStatus("Please type a message to be sent.");
        }
      }

      var objectURL;
      function handleFileSelect(evt) {
        if (evt.target.files.length>0) {
          files = evt.target.files;
          f = files[0];
          objectURL = window.webkitURL.createObjectURL(f);
          evt.target.files = [];
          getImageDimensions(objectURL, function(size) {
            if (size.width % 16 != 0 || size.height % 16 != 0) {
              updateStatus("Error: please select an image with width and height as a multiple of 16 (e.g. 960*720).")
            } else {
              var coefficientCount = (size.width * size.height / 64) - Math.floor(1+5*3*8*mlbcForEncodingAndDecoding.n/mlbcForEncodingAndDecoding.k);
              var maxLength = Math.floor(coefficientCount/8*mlbcForEncodingAndDecoding.k/mlbcForEncodingAndDecoding.n);
              updateStatus("This image has space for "+maxLength+" characters of hidden message");
              document.getElementById("message").value = document.getElementById("message").value.slice(0, maxLength);
              document.getElementById("message").setAttribute("maxlength", maxLength);
            }
          });
          document.getElementById("encoded").src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        }
      }

      document.getElementById("image-select").addEventListener("change", handleFileSelect, false);
      document.getElementById("decodeButton").addEventListener("click", decodeImageClicked);
      document.getElementById("encodeButton").addEventListener("click", encodeImageClicked);


      // function compareArrays() {
      //   var blocks = decodedLumaArr.length;
      //   errors = [];
      //   totals = [];
      //   for (var i = 0; i < blocks; i++){
      //     for (var k = 0; k < 64; k++) {
            
      //       if (errors[k] == undefined) {
      //         errors[k] = 0;
      //         totals[k] = 0;
      //       }

      //       if (decodedLumaArr[i][k] != 0) {
      //         if (decodedLumaArr[i][k] != encodedLumaArr[i][k]) {
      //           errors[k]++;
      //         }
      //         totals[k]++;
      //       }

      //     }
      //   }
      //   for (var k = 0; k < 64; k++) {
      //     errorRate = errors[k]/totals[k];
      //     if (isNaN(errorRate)) {
      //       errorRate = 0;
      //     }
      //     errorRate = Math.round(errorRate*1000)/10;
      //     console.log(k+": "+errors[k]+" errors in "+totals[k]+" non-zeros. "+errorRate+"%");
      //   }
      // }

    </script>
  </body>
</html>
